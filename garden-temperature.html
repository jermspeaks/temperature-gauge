<link rel="import" href="../polymer/polymer.html">

<!--
`garden-temperature`
# Temperature gauge

## Reusable element for Grow IoT

### Dependencies

- d3

@demo demo/index.html
-->

<dom-module id="garden-temperature">
  <template>
    <style>
      :host {
        display: block;
      }
    </style>
    <h2>Hello [[name]]</h2>
    <svg id="gardentemperature">
      <defs>
        <linearGradient id="temp-gradient" x1="0%" y1="0%" x2="100%" y2="0%">
          <stop offset="0%" style="stop-color:#7dace7;stop-opacity:1" />
          <stop offset="50%" style="stop-color:#fff;stop-opacity:0" />
          <stop offset="100%" style="stop-color:#e7827d;stop-opacity:1" />
        </linearGradient>
      </defs>
    </svg>
  </template>
  <script src="../d3/d3.min.js"></script>
  <!-- Bower doesn't bundle these for some reason -->
  <!-- <script src="https://d3js.org/d3-color.v0.5.min.js"></script> -->
  <!-- <script src="https://d3js.org/d3-interpolate.v0.9.min.js"></script>
  <script src="https://d3js.org/d3-scale-chromatic.v0.3.min.js"></script> -->

  <script>
    Polymer({

      is: 'garden-temperature',

      properties: {
        /**
         * The markdown source that should be rendered by this element.
         */
        name: {
          type: String,
          value: 'garden-temperature'
        },
        temperature: {
          type: Number,
          value: 65
        }
      },
      /**
       * Create elements for charts
       */
      createElements: function() {
        this.WIDTH = 350;
        this.HEIGHT = 350;
        this.INNER_RADIUS = 60;
        this.OUTER_RADIUS = 120;
        this.CORNER_RADIUS = 1;
        this.PAD_ANGLE = 0;
        this.DOMAIN = [0, 100];
        this.RANGE = [-45, 225];

        this.svg = d3.select(this.$.gardentemperature)
          .attr( "width", this.WIDTH )
          .attr( "height", this.HEIGHT );

        this.arc = d3.arc()
          .innerRadius(this.INNER_RADIUS)
          .outerRadius(this.OUTER_RADIUS)
          .cornerRadius(this.CORNER_RADIUS)
          .padAngle(this.PAD_ANGLE);

        this.tickLine = d3.radialLine()
          .radius(this.OUTER_RADIUS)
          .angle(d => -d + Math.PI / 2);

        this.textArc = d3.arc()
          .outerRadius(this.OUTER_RADIUS);

        this.color = ["#2776d7", "#7dace7", "#e9f1fb", "#fff", "#fbeae9", "#e7827d", "#d73027"];

        this.tempScale = d3.scaleLinear().domain(this.DOMAIN).range(this.RANGE);
      },
      /**
       * Draws the chart
       */
      drawChart: function () {
        var self = this;
        var gauge = self.makeGaugeData();
        var temp = self.getData();
        var ticks = self.makeTicks();

        self.pie = d3.pie()
          .startAngle( -(3 * Math.PI) / 4 )
          .endAngle( (3 * Math.PI) / 4 )
          .value(d => d);

        self.groupArcs = self.svg.append('g')
          .attr("class", "arcs-group");

        self.arcs = self.groupArcs.selectAll( '.arc' )
          .data(self.pie([1])) // pass arc data
          .enter()
          .append('path')
          .attr("transform", "translate(200,200)")
          .attr("d", self.arc)
          .attr("stroke", "#000")
          .attr("stroke-width", "1px")
          .style("fill", "url(#temp-gradient)");

        self.groupTicks = self.svg.append("g")
          .attr("class", "ticks-group")
          .selectAll("g")
          .data(d3.range(-45, 245, 27))
          .enter()
          .append("g")
          .attr("transform", d => "translate(200, 200) rotate(" + -d + ")");

        self.groupTicks.append("text")
          .attr("x", self.OUTER_RADIUS + 6)
          .attr("dy", ".35em")
          .style("text-anchor", d => d < 270 && d > 90 ? "end" : null)
          .attr("transform", d => {
            if (d < 270 && d > 90) {
              return "rotate(180 " + (self.OUTER_RADIUS + 6) + ",0)";
            } else {
              return null;
            }
          })
          .text((d, i) => ((11 - (i + 1)) * 10) + "°F");

        self.groupTicks.append("line")
          .attr("x1", self.INNER_RADIUS)
          .attr("x2", self.OUTER_RADIUS)
          .attr("y1", 0)
          .attr("y2", 0)
          .style('fill', 'none')
          .style('stroke', '#777')
          .style('stroke-dasharray', '1,4');

        self.needle = self.svg.selectAll(".needle")
          .data(temp)
          .enter()
          .append('line')
          .attr("x1", 0)
          .attr("x2", -115)
          .attr("y1", 0)
          .attr("y2", 0)
          .style("stroke", "black")
          .attr("transform", d => `translate(200,200) rotate(${this.tempScale(d)})`);

        self.tempText = self.svg.append('text')
          .attr('class', 'temp-text')
          .style('font-size', '32px')
          .attr("transform", d => "translate(200, 280)")
          .attr("text-anchor", "middle")
          .text(() => parseFloat(temp, 10).toFixed(0).toString() + '°F');
      },
      /**
       * Creates Gauge Data
       * @param  {Number} N   Number of splits in gauge
       * @return {array}      Array of numbers as value equal to 1
       */
      makeGaugeData: function(N) {
        var elements;
        if (N) {
          elements = N;
        } else {
          elements = 10;
        }

        return Array.apply(null, { length: elements }).map(Number.call, Number).map(() => 1);
      },
      /**
       * Creates list for ticks
       * @return {array} list of temperatures for tick marks
       */
      makeTicks: function() {
        return Array.apply(null, { length: 10 }).map(Number.call, Number).map(num => (num + 1) * 10);
      },
      /**
       * Gets data from properties and places it in an array
       * @return {array} Tempature Data in a list
       */
      getData: function() {
        // This is the getter for the data
        return [this.temperature];
      },
      ready: function () {
        this.createElements();
        this.drawChart();
        // this.getData();
      },

    });
  </script>
</dom-module>
